<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Jet DataBase Engine и DAO</title>
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>
    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <script src="js/jquery.arcticmodal-0.3.min.js"></script>

    <link rel="stylesheet" href="css/jquery.fancybox.css?v=2.1.5" type="text/css" media="screen" />
    <script type="text/javascript" src="js/jquery.fancybox.pack.js?v=2.1.5"></script>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
        <style type="text/css" media="screen">
            body { padding-top: 80mapx; }
        </style>
  </head>
  <body>
        <script type="text/javascript">
      	$(document).ready(function() {
      		$(".fancybox").fancybox();
      	});
      </script>
      <div class="container">
          <nav class="navbar navbar-default navbar-fixed-top" role="navigation" style="margin-bottom: 200px;">
            <div class="container">
              <ul class="nav navbar-nav">
                          <li class="active"><a href="#">Jet Datatbase и DAO</a></li>
                          <li><a href="#">Информация</a></li>
                          <li><a href="test.html">Тест</a></li>
                        </ul>
            </div>
          </nav>
        <div class="row">
            <div class="md-col-12">
                <h3>Оптимизация Jet DataBase Engine.</h3>
                <h3>Работа с БД VBA. Технологии ADO, DAO</h3>
            </div>
        </div>  
        <div class="row">
            <div class="md-col-12">
                <ul>
                    <li><a href="#r1">РАЗДЕЛ 1 Оптимизация приложений</a></li>
                    <li><a href="#r2">Раздел 1.2 Оптимизация настройки механизма Jet Database Engine</a></li>
                    <li><a href="#r3">Раздел 1.3 Безопасное изменение установок Jet</a></li>
                    <li><a href="#r4">Раздел 1.4 Средства оценки производительности</a></li>
                    <li><a href="#r5">Раздел 1.5 Оптимизация базы данных</a></li>
                    <li><a href="#r6">Раздел 1.6 Оптимизация базы данных</a></li>
                    <li><a href="#r7">Раздел 1.7 Использование SQL вместо DAO</a></li>
                    <li><a href="#r8">РАЗДЕЛ 2. ТЕХНОЛОГИЯ DAO</a></li>
                    <li><a href="#r9">РАЗДЕЛ 3 . ТЕХНОЛОГИЯ ADO</a></li>
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="md-col-12">
            <h4>Введение</h4>
            <p class="text-justify">В данной главе описаны методики оптимизации приложения. Время реакции хорошо работающего приложения обычно составляет менее одной секунды для большинства операций получения данных. Методики, изложенные в данной главе, помогут разработчику придерживаться такого стандарта.
            Простейший способ обеспечения быстрой работы приложения заключается в модернизации компьютера, на котором оно выполняется. Кроме того, можно изменить установки в системном реестре, чтобы они соответствовали требованиям выполняющегося процесса. В этой главе подробно описано составление таблиц и запросов, обеспечивающее приложению основу для достижения высокой производительности. Рассмотрены подходы к дизайну интерфейса, помогающие создать надлежащий вид приложения и позволяющие уведомить пользователей о ходе процесса. Наконец, изложены способы кодирования, обеспечивающие использование каждой миллисекунды для повышения быстродействия приложения.
            Начав с аппаратного обеспечения, пробуя различные описанные подходы и проверяя их в той или иной ситуации, разработчик сможет добиться самой высокой производительности приложения. Совокупное применение приведенных методик может иметь поразительный эффект в каждом конкретном случае.
            </p>
            </div>
        </div>
        <div class="row">
            <div class="md-col-12">
                <a name="r1"></a>
                <h4>Раздел 1 Оптимизация приложений</h4>
                <blockquote>
                  <p class="text-justify">По материалам книги Стивена Форта, Тома Хоуна и Джеймса Релстона</p>
                </blockquote>
                <p class="text-justify">
                    Что же означает термин "оптимальный"?
                </p>
                <p class="text-justify">
                    Одни полагают, что "оптимальный" - значит самый быстрый, поэтому самая высокоскоростная технология всегда будет оптимальной.
                </p>
                <p class="text-justify">
                    Другие утверждают, что оптимальным - является такое решение, которое обеспечивает большую надежность, даже если при этом приложение работает медленно и
                    генерирует чрезмерное количество предупреждений.
                </p>
                <p class="text-justify">
                    Третьи считают, что целью оптимизации - является эксплуатационная надежность и расширяемость.
                </p>
                <p class="text-justify">
                    Но кто же прав?
                </p>
                <p class="text-justify">
                    На самом деле оптимизация представляет собой попытку уравновесить все три представленные мнения.
                </p>
                <p class="text-justify">
                    То есть оптимальным является такое решение, которое обеспечивает пользователя приемлемым быстродействием приложений.
                </p>
                <blockquote> 
                <p class="text-justify">
                    Необходимо помнить, что приложение, помимо скорости выполнения задач, должно быть надежным, стабильно работающим и расширяемым.
                </p>
                          </blockquote>
                <p class="text-justify">
                    Разные методики, описанные ниже, подходят к определенным программам, то есть не каждый подход будет оптимален. Единственный способ узнать, подойдут ли
                    данные методики, — поэкспериментировать с ними.
                </p>
            </div>
        </div>
        <div class="row">
            <div class="md-col-12">
                <a name="r2"></a>
                <h4>Раздел 1.2 Оптимизация настройки механизма Jet Database Engine</h4>
                <p class="text-justify">
                    Хорошо настроенный компьютер и оптимизированная инсталляция базы данных не помогут повысить производительность, если не оптимизировано само приложение.
                    Настоящее приложение базы данных состоит из нескольких частей.
                </p>
                <p class="text-justify">
                    Самой важной из них является механизм баз данных Jet.
                </p>
                <p class="text-justify">
                    Механизм 
                    Jet
                    — это центр почти всего, что происходит в приложении баз данных Access, и его можно оптимизировать точно так же, как и другие функции Access. Попытки
                    оптимизировать Jet должны быть предприняты после разработки большей части, если не всего, приложения; при этом необходимо затратить достаточное количество
                    времени на оценку различных методик оптимизации.
                </p>
                <p class="text-justify">
                    Jet 4.0, который поставляется вместе с Access 2000, обладает несколькими преимуществами над своими предшественниками.
                </p>
                <p class="text-justify">
                    Такие возможности, как:
                </p>
                <ul>
                    <li>
                        новые типы данных;
                    </li>
                    <li>
                        сжатие текста;
                    </li>
                    <li>
                        индексация полей примечаний;
                    </li>
                    <li>
                        внедрение ANSI SQL-92;
                    </li>
                    <li>
                        управление SQL Security;
                    </li>
                </ul>
                <p class="text-justify">
                    · большая гибкость в работе с внешними индексами;
                </p>
                <p class="text-justify">
                    · улучшенная схема репликации и улучшенные блокировки, обещают способствовать повышению производительности.
                </p>
                <blockquote>
                <p class="text-justify">
                    Механизм Jet выполняет основную оптимизацию без вмешательства разработчика или пользователя.
                </p>
            </blockquote>
                <p class="text-justify">
                    Из всех сложных действий, которые выполняет Jet, можно увидеть только около 15, если заглянуть в системный реестр. Эти установки оказывают серьезное
                    влияние на многие аспекты функционирования системы. Изменение установки может привести к результату, совершенно противоположному тому, который ожидался.
                    Даже если приложение на первый взгляд работает быстрее, может оказаться, что нанесен серьезный ущерб стабильности и совместимости
                </p>
            </div>
        </div>
        
        <div class="row">
            <div class="md-col-12">
                <a name="r3"></a>
                <h4>РАЗДЕЛ 1.3 Безопасное изменение установок Jet</h4>
                <p align="left">
                    Существует три способа, позволяющие изменить установки Jet в системном реестре:
                </p>
                <ol>
                    <li>
                    Непосредственное изменение установок, принятых по умолчанию, с помощью RegEdit.exe
                    </li>
         
                    <li>
                    Создание пользовательского профиля для отмены установок, принятых по умолчанию, и вызов данного профиля с помощью опции командной
                    строки /profile,
                </li>
              
     
                    <li>Временная отмена в приложении установок, принятых по умолчанию, с помощью метода SetOption объекта базы данных.</li>
                </ol>
                <blockquote>
                <p class="text-justify">
                    Наиболее предпочтительна третья опция. Ее использование не только не вызывает сложностей, но и позволяет настроить каждое приложение отдельно.
                </p>
                </blockquote>
                <p class="text-justify">
                    В приложении можно даже изменять установки в разное время, чтобы действительно оптимизировать быстродействие. При таком подходе установки, принятые по
                    умолчанию, никогда не изменяются, поэтому новые проекты начинаются на общей основе.
                </p>
                
                <p class="text-justify">
                    Для временной отмены установок в системном реестре нет необходимости использовать вызовы API.
                </p>
                <p class="text-justify">
                    Механизм баз данных предлагает метод, который использует два аргумента. Синтаксис приведен ниже:
                    <p class="text-justify">
                    <code>
                        DBEngine.SetOption ConstantNameofSetting, value
                    </code>
                    </p>
                </p>
                <p class="text-justify">
                    Например, производительность пакета обновлений можно повысить, если заставить Jet ожидать несколько дольше перед выполнением неявных транзакций. Соответствующий код для временного увеличения периода ожидания SharedAsync Delay до 1 секунды (1000 миллисекунд) должен быть таким:
                    <code>DBEngine.SetOptiuon dbSharedAsyncDelay, 1000</code>
                    
                </p>
            </div>
        </div>
        <a name="r4"></a>
        <div class="row">
            <div class="md-col-12">
                
                <h4>Раздел 1.4 Средства оценки производительности</h4>
                <p class="text-justify">
                    Для отслеживания и оценки относительной производительности, достигнутой с помощью той или иной методики, можно использовать несколько разных
                    инструментальных средств.
                </p>
                <p class="text-justify">
                    Первый способ
                    — это таймер для измерения количества времени, которое занимает выполнение процесса.
                </p>
                <p class="text-justify">
                    Второй способ
                    — недокументированная функция для подсчета операций с диском, кэшем и операций блокировки.
                </p>
                <p class="text-justify">
                    Третий способ
                    — способность Access отобразить план выполнения запросов для просмотра разработчиком.
                </p>
                <p class="text-justify">
                    Пример 1. Определение времени выполнения запроса.
                    <code><p class="text-justify">
    Sub QueryTimer(strQueryName As String)</p>
<p class="text-justify">
    Dim db As Database 
</p>
<p class="text-justify">
    Dim qry As QueryDef 
</p>
<p class="text-justify">
    Dim rs as Recordset
</p>
<p class="text-justify">
    Set db = CurrentDb() 
</p>
<p class="text-justify">
    Set qry <em>=</em> db.QueryDefs(strQueryName)
</p>
<p class="text-justify">
    '
    Запуск
     
    часов
    . a2kuStartClock
</p>
<p class="text-justify">
    Set rs = qry.OpenRecordset()
</p>
<p class="text-justify">
    'Остановка часов и вывод результата в окне отладки. 
    
</p>
<p class="text-justify">
    Debug.Print strQueryName &amp; " executed in: " &amp; a2kuEndClock &amp; _
</p>
<p class="text-justify">
    " milliseconds"
</p>
<p class="text-justify">
    rs.Close 
</p>
End Sub
                        
                    </code>
                </p>
            </div>
        </div>
        <a name="r5"></a>
       <div class="row">
           <div class="md-col-12">
               <h4>Раздел 1.5 Оптимизация базы данных</h4>
               <p class="text-justify">Реляционные базы данных, включая Access, основываются на таблицах информации. Конструкция этих таблиц и отношения между ними оказывают сильное влияние на производительность приложения. Если таблицы не оптимизированы, проиндексированы и обращаются к свойствам друг друга, каждый запрос и процедура кода выполняются значительно дольше.</p>
               <blockquote>
                 <p class="text-justify">Лучшее, что можно сделать для оптимизации базы данных, — правильно сконструировать таблицы.</p>
               </blockquote>
           </div>
       </div> 
       <div class="row">
           <div class="md-col-12">
               <h4>Раздел 1.5.1 Составление таблиц данных</h4>
               Кроме обычных правил оптимизации, при построении таблиц необходимо помнить о следующем:
               <ul>
               <li>При работе со связанными таблицами следует создавать постоянные связи.</li>
               <li>Использование простых подтаблиц в таблицах, где подтаблица является другой таблицей, а связи главный/подчиненный используют индексированные поля, оказывает ничтожно малое отрицательное влияние на производительность; однако более сложная подтаблица может значительно уменьшить скорость выполнения приложения. Вместо таблиц в запросах следует использовать подтаблицы. В данном случае они используются только при необходимости, а не каждый раз при открытии таблицы.</li>
               <li>Шаблоны ввода, поиска и правила верификации также должны использоваться только там, где они действительно необходимы, — в формах. Лучше всего создавать как можно более простые и легкие таблицы.</li>
               <li>Не рекомендуется создавать поля данных, размер которых будет больше, чем необходимо. Access предоставляет место для данных по размеру поля этих данных. Можно впустую потратить массу свободного места (и времени), используя типы данных или установки свойств, слишком большие для данных, содержащихся в этих полях.</li>
               </ul>
               
           </div>
       </div> 
       <div class="row">
            <div class="md-col-12">
                <h4>Раздел 1.5.2 Нормализация данных в целях повышения производительности</h4>
                Несколько замечаний о нормализации:
                <ul>
                <li>Нормализованная база данных позволяет экономить дисковое пространство, а также препятствует появлению конфликтующих или некорректных данных, поскольку она не содержит повторяющихся данных.</li>
                <li>В нормализованной базе данных используется меньше страниц данных и индексов, что ускоряет поиск.</li>
                <li>Правила нормализации можно нарушать в тех случаях, когда это имеет смысл. Нарушение правил нормализации иногда позволяет повысить производительность для некоторых частей приложения. Но всегда следует помнить о том, что такое нарушение может повлиять на надежность, целостность данных и эксплуатационные качества.</li>
                </ul>
                <p class="text-justify">
                    Идеальная схема нормализации заставила бы разработчика создать таблицу контактов с полем ID покупателя, полем типа контакта и другими полями для хранения номеров телефонов и адресов электронной почты. Вероятно, такой подход можно считать излишеством, а дополнительная целостность и гибкость не стоят затраченных усилий. Вполне разумно хранить эту информацию в таблице покупателей и воспользоваться преимуществами повышенной производительности. Однако правило заключается в том, что нужно нормализовать все, что возможно. 
                    <blockquote><p class="text-justify">то то, чего ожидает Jet, так как лучше всего он работает с нормализованными данными.</p></blockquote>
                    
                </p>
            </div>
        </div>
        <div class="row">
             <div class="md-col-12">
                 <h4>Раздел 1.5.3 Создание индексов, ускоряющих выполнение запросов</h4>
                 <ul>
                     <li>Индексы могут ускорить процесс получения данных примерно в 10 раз.</li>
                     <li>Индексы, кроме того, могут замедлить обновления и ввод данных, поэтому их не следует создавать без особой необходимости.</li>
                     <li>Можно проиндексировать все поля, для которых приложение применяет условие отбора. Создание индексов на множественных полях в таблицах упростит оптимизацию запросов, созданных позже в процессе разработки.</li>
                 </ul>
             </div>
         </div>
        <div class="row">
             <div class="md-col-12">
                 <h4>Раздел 1.5.4 Раннее создание отношений для повышения производительности</h4>
                 <p class="text-justify">
                     Отношения между таблицами рекомендуется устанавливать в окне <strong>Relationships</strong><strong> (Отношения)</strong>. При создании отношения в этом
                     окне разработчик имеет возможность определить свойства данного отношения. Кроме того, при этом Jet узнает о существовании отношения. Jet может использовать
                     всю эту информацию для создания более эффективного плана оптимизации при запросах к данным. Это значительно повышает производительность.
                 </p>
                 <p class="text-justify">
                     Итак, следует:
                 </p>
                 <ul>
                     <li>
                         нормализовать данные,
                     </li>

                 <li>
                     создать индексы там, где они необходимы,
                 </li>
                 <li>
                     экономно обращаться с типами данных и размерами,
                 </li>
                 <li>
                     помнить о том, что таблицы должны быть простыми.
                 </li>
                                  </ul>
           </div>
       </div> 
    <div class="row">
         <div class="md-col-12">
             <h4>Раздел 1.5.4 Раннее создание отношений для повышения производительности</h4>
             <p class="text-justify">
                 Большую часть работы в приложении выполняют запросы. Реляционная база данных была бы бесполезной без возможности выполнять запросы к данным. Однако запросы
                 создаются по-разному. Даже если разработчик принял все меры для нормализации данных и создал все необходимые индексы, можно иметь запросы, которые
                 выполняются не так быстро, как могли бы. Может даже существовать два запроса, дающие идентичный результат, но выполняющиеся по-разному.
             </p>
             <p class="text-justify">
                 Чтобы понять, как оптимизировать запросы, необходимо понимать,<strong> </strong>как их обрабатывает<strong> </strong>Jet<strong>.</strong> Каждый запрос
                 проходит четыре этапа:
             </p>
             <ul>
             <li>
                 1. Определение — создается SQL-оператор с помощью одного из нескольких инструментальных средств.
             </li>
             <li>
                 2. Компиляция — SQL-строка разбивается на составные части.
             </li>
             <li align="left">
                 3. Оптимизация — используя алгоритм оценки стоимости. Jet формулирует и тестирует несколько различных способов получения результата, который удовлетворяет
                 данному SQL-оператору.
             </li>
             <li align="left">
                 4. Выполнение — используя план оптимизации, Jet передает результирующий набор пользователю.
             </li>
         </ul>
             <p class="text-justify">
                 Можно определить запрос с помощью QBE Grid, SQL-строки, выполняющейся в коде, SQL-строки в свойстве источника формы, отчета или элемента управления либо с
                 помощью любого другого средства, которое способно создавать SQL-операторы.
             </p>
             <p class="text-justify">
                 Jet размещает составные части строки в иерархической внутренней структуре. Эти части весьма напоминают ключевые слова SQL-оператора.
             </p>
             <ul>
             <li>
                 1. В основе лежат базовые таблицы, используемые запросом (Из).
             </li>
             <li>
                 2. Потом устанавливаются столбцы результата (Выбор).
             </li>
             <li>
                 3. Далее следуют условия отбора или ограничения, заданные запросом (Где).
             </li>
             <li>
                 4. Затем оцениваются отношения базовых таблиц (Объединение).
             </li>
             <li>
                 5. Наконец, происходит сортировка результирующего набора (Сортировка).
             </li>
             <li>
                 Такая структура переходит в фазу оптимизации.
             </li>
             </ul>
             <p class="text-justify">
                 Оптимизация представляет собой самый сложный этап. Jet оценивает и рассчитывает стоимость каждого возможного подхода. Это делается путем рассмотрения
                 запроса под двумя различными углами: с точки зрения доступа к базовым таблицам и с точки зрения исследований связей между ними. Понимание действий Jet
                 может способствовать разработке более быстрых запросов в дальнейшем.
             </p>
         </div>
     </div>
     <a name="r6"></a>
    <div class="row">
         <div class="md-col-12">
             <h4>Раздел 1.6 Оценка типа результирующего набора для достижения оптимальной производительности</h4>
             <p class="text-justify">
                 Jet, кроме того, рассматривает запрашиваемый результирующий набор. Например, для представления динамического множества может быть выполнен план, который
                 эффективно представляет первую страницу данных, даже если отображение оставшихся записей происходит медленнее. Для образования динамического множества Jet
                 создает набор уникальных ключевых значений, которые указывают на строки соответствующей базовой таблицы.
             </p>
             <p class="text-justify">
                 Таким образом, для Jet достаточно получить только ключевые значения, а оставшиеся записи будут отображены тогда, когда они понадобятся пользователю.
             </p>
             <p class="text-justify">
                 Однако в снимках Jet перед представлением результата собирает все записи и столбцы для результирующего набора. Если весь снимок не помещается в памяти, его
                 часть переходит в файл подкачки, что отрицательно сказывается на производительности.
             </p>
             <h4>Повышение скорости выполнения запросов</h4>
<p class="text-justify">Советы, которые помогут ускорить выполнение запросов:</p>
<ul>
<li>Рекомендуется создавать индексы для всех полей, которые будут использованы для определения критерия отбора.</li>
<li>Необходимо создавать индексы с обеих сторон связей в запросах.</li>
<li>Вместо уникальных индексов лучше пользоваться начальными значениями. Поскольку начальные значения запрещают использование пулевых значений, запрос может использовать преимущества большего количества типов объединения.</li>
<li>В результирующем наборе не следует отображатькакие-либо лишние столбцы. Обработка и отображение каждого столбца занимает дополнительное время.</li>
<li>Рекомендуется воздерживаться от употребления сложных выражений в запросах.</li>
<li>Следует избегать функции<strong>IIF</strong><strong>()</strong> (немедленное IF).<strong>IIF</strong><strong>()</strong> оценивает и истинное, и ложное значения перед тем, как выдать результат. Если выполнять данную операцию для каждой записи, это может <strong>сильно повлиять на</strong> производительность.</li>
<li>При использовании вложенных запросов рекомендуется записывать все вычисления в последнем запросе серии.</li>
<li>Вместо<strong>Count</strong><strong>([</strong><strong>Customer</strong><strong>])</strong> лучше применять<strong>Count</strong><strong>(*),</strong> поскольку при срочной оптимизации<strong>Count</strong><strong>(*) </strong>обрабатывается быстрее &mdash; перед подсчетом не нужно проверять нулевые значения.</li>
<li>По возможности следует пользоваться оператором Between для уменьшения количества строк в ре&shy;зультирующем наборе вместо операторов "больше чем" и "меньше чем".</li>
<li>Обычно размещение условия со стороны "один" отношения "один-ко-многим" &mdash; самый эффектив&shy;ный способ, но не всегда. Можно попробовать передвинуть ограничение к стороне "многие", что&shy;бы проверить, не изменится ли производительность. После каждого изменения условий отбора необходимо тщательно проверять результирующий набор.</li>
<li>Нормализованные таблицы могут хранить данные с использованием меньшего количества страниц данных и страниц индекса. Нормализация должна стать правилом, и нарушать ее можно лишь при отсутствии другой альтернативы.</li>
<li>Рекомендуется по возможности поэкспериментировать с подчиненными запросами вместо исполь&shy;зования объединений или сложных условий OR. Оптимальный выбор зависит от многих дискретных факторов, и только эксперимент поможет решить, какой подход использовать.</li>
<li>Внешние связи следует использовать только при крайней необходимости, поскольку они автомати&shy;чески требуют проведения сканирования доминантной (сохраняемой) таблицы в объединении.</li>
<li>Вместо SQL-операторов в коде рекомендуется использовать сохраненные запросы с параметрами. Jet уже скомпилировал запросы с параметрами и создал для них план выполнения (хотя эти планы не&shy;доступны в SHOWPLAN.OUT). Использование скомпилированных и сохраненных запросов устраняет необходимость оценки и оптимизации SQL-строки. Access компилирует SQL-строки, использующиеся в качестве источника записей или источника строк для форм, отчетов или элементов управления, поэтому они остаются нетронутыми.</li>
<li>Рекомендуется всегда использовать скомпилированные запросы.</li>
<li>Для манипуляций с данными вместо DAO по возможности следует пользоваться запросами. Для решения этих задач запросы (SQL) всегда выполняются быстрее, чем DAO.</li>
</ul>
                <a name="r7"></a>
             <h4>Раздел 1.7 Использование SQL вместо DAO</h4>
             <p class="text-justify">Работать с наборами записей рекомендуется только в<strong> том</strong> случае, если нет другой альтернативы. Механизм баз данных Jet для манипуляций над данными и структурами данных оптимизирован на использование SQL. При каждой возможности вместо DAO следует использовать запросы SQL. Очень редко DAO работает быстрее, чем правильно составленный запрос. В отличие от DAO, запросы имеют план выполнения и используют преимущества индексации.</p>
             <p class="text-justify">Если необходимо адресовать данные через объектную модель, рекомендуется вместо DAO использовать ADO. ADO &mdash; новый стандарт для манипуляций с адресацией данных и определением данных через объектную модель. Разработка дальнейших версий DAO прекращена, и никаких улучшений или расширений в будущем не последует.&nbsp;</p>
         </div>
     </div>    
     <a name="r8"></a>
    <div class="row">
         <div class="md-col-12">
             <h4>РАЗДЕЛ 2. ТЕХНОЛОГИЯ DAO</h4>
             <a class="fancybox" rel="group" href="img/2.png">
               <img src="img/2.png" class="img-responsive" alt="" />
             </a>
             <p class="text-justify">Объекты доступа к данным (DAO - аббревиатура от слов&nbsp; Data Access Objects) используются обычно для работы с данными. При помощи DAO можно создать всю БД и некоторые из встроенных процедур MS Access.</p>
             <p class="text-justify">Однако этого не следует делать. Некоторые задачи проще выполнить через пользовательский интерфейс, например, такие как:</p>
             <ul>
             <li>создание запросов</li>
             <li>задание связей между таблицами.</li>
             </ul>
             <p class="text-justify">Некоторые методы и свойства объектов DAO, однако, могут быть полезны, так как они автоматизируют и упрощают решение обыденных задач, которые утомительны или избыточны при выполнении через пользовательский интерфейс.</p>
             <p class="text-justify">К таким задачам относятся:</p>
             <ul>
             <li>задачи манипуляции данными,</li>
             <li>выполнение транзакций над данными при многопользовательской работе</li>
             <li>установка защиты данных.</li>
             </ul>
             <p class="text-justify">Каждый объект DAO логически строится из других объектов. Многие объекты DAO содержат семейства других объектов. Каждый объект DAO служит определенной цели и имеет методы и свойства, которые позволяют разрабатывать и управлять этим объектом и любым объектом, который он содержит.</p>
             <p class="text-justify">Семейство является набором объектов одного типа. Каждый объект в семействе может также содержать семейства других объектов. Таким образом, семейство может содержать ноль или более объектов одного типа, и объект может содержать ноль или более семейств.</p>
             <p class="text-justify">Свойство описывает один аспект состояния или характеристики объекта. В DAO семейство Properties описывает все состояния и характеристики объекта. Семейства DAO имеют единственное свойство Count, которое используется для определения количества объектов в семействе.</p>
             <code>
                 Dim intPropCount As Integer<br>
                 intPropCount = DBEngine.Properties.Count
                 
             </code>
             <p class="text-justify">Объекты и семейства имеют методы. Количество методов для семейств также ограничено. В иерархии DAO семейства могут иметь следующие методы:</p>
             <ul>
             <li>Метод <strong>Append</strong> добавляет объект в семейство после того, как определены свойства объекта</li>
             <li>Метод <strong>Delete</strong> удаляет объект из семейства</li>
             <li>Метод <strong>Refresh</strong> обновляет количество и/или характеристики&nbsp; объектов семейства после того, как они были добавлены или удалены.</li>
             </ul>
             <p class="text-justify">Объект <strong>DBEngine</strong> располагается на вершине иерархии DAO, через который управляется ядро БД (MS Jet). Все объекты в иерархии DAO зависят от этого объекта или на нем основаны. Объект <strong>DBEngine</strong> - единственный объект DAO, который не входит ни в какое семейство. Объект <strong>DBEngine</strong> содержит семейство <strong>Workspaces</strong> объектов <strong>Workspace</strong>.</p>
             <p class="text-justify">Объект <strong>Workspace</strong> (сеанс работы или рабочее пространство).</p>
             <p class="text-justify">Назначение этого объекта заключается в поддержке отдельного журнала транзакций. <strong>Транзакция</strong> - это последовательность действий (работ), которые выполняются как одно действие.</p>
       </div>
   </div> 
  <div class="row">
      <a name="r9"></a>
       <div class="md-col-12">
           <h4>РАЗДЕЛ 3 . ТЕХНОЛОГИЯ ADO</h4>  
           <p class="text-justify">Компанией Microsoft был предложен новый механизм доступа к данным &mdash; технология ADO (ActiveX Data Objects), построенная на использовании интерфейсов OLE DB. Набор интерфейсов OLE DB присутствует во всех операционных системах компании Microsoft, что делает доступ к данным довольно простым. Приложение, работающее по технологии ADO, может использовать данные, представляющие собой либо таблицы Microsoft Access, либо серверные БД Microsoft SQL, Oracle, либо XML-файлы и т.п.<br /> Технология ADO построена на технологии СОМ, т. е. все объекты и интерфейсы ADO являются объектами и интерфейсами&nbsp;</p>
       </div>
   </div>     
    
    
</div>



  </body>
</html>